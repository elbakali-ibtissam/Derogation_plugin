# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DerogationDialog
                                 A QGIS plugin
 ce plugin  est conçu pour aider les utilisateurs à évaluer si un projet de dérogation est favorable ou non dans la ville de Khémisset, au Maroc.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-06-02
        git sha              : $Format:%H$
        copyright            : (C) 2024 by ibtissam
        email                : e.btissam.elbakali@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""




import os
import geopandas as gpd
from shapely.geometry import Point
import csv
import sys

from PyQt5.QtCore import QProcess

from reportlab.lib.units import inch
import plotly.express as px

import webbrowser
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Image
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib import colors

import io
import json
from shapely.geometry import shape, Point, Polygon
from reportlab.platypus import Spacer

from reportlab.pdfgen import canvas

import plotly.graph_objs as go
import plotly.subplots as sp
import plotly.io as pio

pio.renderers.default = 'notebook'  # or 'notebook_connected'
import pandas as pd

from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.figure import Figure
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtWidgets import QFileDialog, QMessageBox,QCheckBox, QWidget, QPushButton, QLineEdit, QTableWidget, QTableWidgetItem
from qgis.core import QgsProject, QgsVectorLayer,QgsGeometry, QgsPointXY,QgsFeature, QgsFeatureRequest,QgsWkbTypes,QgsCoordinateReferenceSystem,QgsCoordinateTransform
from qgis.PyQt.QtCore import QVariant
from qgis.gui import QgsMapToolEmitPoint
from qgis.utils import iface
from selenium import webdriver

from reportlab.lib.pagesizes import A3
from pyproj import Transformer

from reportlab.platypus import SimpleDocTemplate, Table, TableStyle
from reportlab.lib.styles import ParagraphStyle

import folium

pio.orca.config.executable = 'C:/Users/btiss/anaconda3/orca.cmd'











# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'Derogation_dialog_base.ui'))


class DerogationDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(DerogationDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)


        self.pushButton.setVisible(False)
        self.lineEdit.setVisible(False)
        self.label_7.setVisible(False)
        self.lineEdit.setText("")
        self.geojson_path = None
        self.lineEdit_2.setVisible(False)
        self.lineEdit_3.setVisible(False)
        # Connecter les cases à cocher à la méthode de gestion des états
        self.checkBox.stateChanged.connect(self.on_checkbox_state_changed)
        self.checkBox_2.stateChanged.connect(self.on_checkbox_state_changed)
        self.pushButton.clicked.connect(self.choose_file)
        self.label_2.setVisible(False)
        self.label_3.setVisible(False)
        self.pushButton_2.clicked.connect(self.analyze)
        self.pushButton_3.clicked.connect(self.choose_pdf_file)
        self.lineEdit_4.setVisible(False)
        self.pushButton_3.setVisible(False)
        self.checkBox_3.stateChanged.connect(self.on_checkbox)


    def on_checkbox(self):
        if(self.checkBox_3.isChecked()):
            self.lineEdit_4.setVisible(True)
            self.pushButton_3.setVisible(True)
            
        else:
            self.lineEdit_4.setVisible(False)
            self.pushButton_3.setVisible(False)


    def choose_pdf_file(self):
        pdf_path, _ = QFileDialog.getSaveFileName(self, "Choisir le chemin du PDF", "", "PDF Files (*.pdf)")
        if pdf_path:
            self.lineEdit_4.setText(pdf_path)


      
    def on_checkbox_state_changed(self, state):
        if self.sender() == self.checkBox and state == 2:
            self.checkBox_2.setChecked(False)
            
            self.pushButton.setVisible(True)
            self.lineEdit.setVisible(True)
            self.label_2.setVisible(False)
            self.label_3.setVisible(False)
            self.lineEdit_2.setVisible(False)
            self.lineEdit_3.setVisible(False)
            self.pushButton.clicked.connect(self.choose_file)
        elif self.sender() == self.checkBox_2 and state == 2:
            self.checkBox.setChecked(False)
          
            self.pushButton.setVisible(False)
            self.lineEdit.setVisible(False)
            self.label_2.setVisible(True)
            self.label_3.setVisible(True)
           
            self.lineEdit_2.setVisible(True)
            self.lineEdit_3.setVisible(True)



    def choose_file(self):
        geojson_path, _ = QFileDialog.getOpenFileName(self, "Select GeoJSON File", "", "GeoJSON Files (*.geojson)")
        if geojson_path:
            self.lineEdit.setText(geojson_path)
            self.geojson_path = geojson_path
        else:
            self.geojson_path = None  # Réinitialiser à None si aucun fichier n'est sélectionné

   


    def select_intersecting_features(self,buffer, layer_names):
        for layer_name in layer_names:
            layer = QgsProject.instance().mapLayersByName(layer_name)
            if layer:
                layer = layer[0]
                layer.removeSelection()
                if layer.isValid():
                    features_to_select = [feature.id() for feature in layer.getFeatures() if feature.geometry().intersects(buffer)]
                    layer.selectByIds(features_to_select)

# Ensuite, dans votre méthode analyze, vous pouvez appeler cette fonction comme suit :







    # Fonction pour visualiser le buffer et les entités intersectantes
    def plot_buffer_and_entities(self, buffer, intersecting_entities):
        fig, ax = plt.subplots()
        buffer.plot(ax=ax, color='blue', alpha=0.5)
        for layer_name, entities in intersecting_entities:
            entities.plot(ax=ax, color='red', alpha=0.5, label=layer_name)
        plt.legend()
        plt.show()


















    def generate_analysis_plot(seld,results):
        # Convertissez les résultats en DataFrame pandas pour une manipulation facile
        df = pd.DataFrame(results)

        # Calculer les pourcentages de la surface totale pour chaque couche
        total_area = df['area_sum'].sum()
        df['percentage'] = df['area_sum'] / total_area * 100

        # Créez un graphique en forme de cercle (Pie chart) pour représenter les pourcentages
        pie_chart = go.Pie(labels=df['layer'], values=df['percentage'], hole=0.4)

        # Créer la figure contenant le graphique
        fig = go.Figure(data=[pie_chart])

        # Ajoutez un titre
        fig.update_layout(title='Résultats de l\'analyse du projet de dérogation à Khemisset, Maroc')

        return fig

    def generate_analysis_plot_with_table(self,results):
        fig = self.generate_analysis_plot(results)

        # Ajouter la fonctionnalité d'interaction pour afficher un tableau au clic
        fig.update_traces(hoverinfo='label+percent', textinfo='value', 
                        textposition='inside', showlegend=True)

        fig.update_layout(
            clickmode='event+select',
            annotations=[dict(text="Cliquez sur une partie du graphique pour voir les détails", showarrow=False)]
        )

        return fig







    def plot_statistics(self, total_area_per_layer, buffer_area, derogated_projects_count, project_favorable):
        # Préparer les données pour le graphique à barres
        layers = list(total_area_per_layer.keys())
        areas = list(total_area_per_layer.values())

        # Calculer les pourcentages pour chaque couche
        total_area = sum(total_area_per_layer.values())
        percentages = {layer: (area / total_area) * 100 for layer, area in total_area_per_layer.items()}

        # Préparer les données pour le graphique de camembert
        labels = list(percentages.keys())
        values = list(percentages.values())

        # Créer la figure Plotly pour le graphique à barres
        bar_fig = go.Figure()
        bar_fig.add_trace(go.Bar(x=layers, y=areas, name='Surface intersectée par couche'))
        bar_fig.update_layout(title='Analyse de la surface intersectée par couche',
                        xaxis_title='Couche',
                        yaxis_title='Surface intersectée (m²)')

        # Enregistrer le graphique à barres dans une image
        pio.write_image(bar_fig, 'C:/Users/btiss/Downloads/test_images/statistics_bar_chart.png')

        # Enregistrer la figure Plotly pour le graphique à barres dans un fichier HTML
        output_html ='C:/Users/btiss/Downloads/intersection_area_analysis.html'
        pio.write_html(bar_fig, output_html)

        # Créer le graphique de camembert avec Plotly
        pie_fig = go.Figure(data=[go.Pie(labels=labels, values=values)])
        pie_fig.update_layout(title='Répartition de la surface totale du buffer par couches', font=dict(size=12))

        # Enregistrer le graphique de camembert dans une image
        pio.write_image(pie_fig, 'C:/Users/btiss/Downloads/test_images/statistics_pie_chart.png')

        # Ouvrir le fichier HTML dans un navigateur
        webbrowser.open(output_html)

























    def analyze(self):
        self.label_7.setVisible(True)
        # Récupérer les valeurs des widgets
        buffer_radius = float(self.comboBox.currentText())
        dataframes = []
        if self.checkBox.isChecked():
            file_path = self.lineEdit.text()

            # Charger le fichier GeoJSON en tant que couche vectorielle
            geojson_layer = QgsVectorLayer(file_path, "GeoJSON Layer", "ogr")
            if not geojson_layer.isValid():
                print("Impossible de charger le fichier GeoJSON.")
                return

            # Ajouter la couche à la carte QGIS
            QgsProject.instance().addMapLayer(geojson_layer)

            # Créer le GeoDataFrame à partir de la couche vectorielle chargée
            input_data = gpd.read_file(file_path)
            
            # Supposons que le fichier contient un seul polygone
            input_geometry = input_data.unary_union  # Combine toutes les géométries en une seule
            input_centroid = input_geometry.centroid

            # Convertir les coordonnées du centroïde
            input_centroid_x, input_centroid_y = input_centroid.x, input_centroid.y
            new_centroid = self.convert_coordinates(input_centroid_x, input_centroid_y, "EPSG:4326", "EPSG:26191")

            print(new_centroid.x(), new_centroid.y())

            # Créer le buffer
            buffer = self.create_buffer(new_centroid, buffer_radius)








           
        elif self.checkBox_2.isChecked():
            x = float(self.lineEdit_2.text())
            y = float(self.lineEdit_3.text())
            input_geometry = QgsPointXY(x, y)
            input_centroid = input_geometry
        # Créer le buffer
            buffer = self.create_buffer(input_centroid, buffer_radius)
        else:
            print("Mode de saisie invalide.")
            return
        



        
        couches=["COLLECTIF", "DOMAINE_FORESTIER", "DOMAINE_COMMUNAL", "Derogation_central_13_avril", "DOMAINE_PUBLIC", "DOMIANE_PRIVE_ETAT"]
        # Charger les couches à analyser à partir de QGIS
        layers = {}
        total_area_per_layer = {}  # Dictionnaire pour stocker la superficie totale de chaque couche
        for layer_name in couches:
            layer = QgsProject.instance().mapLayersByName(layer_name)
            if layer:
                layer = layer[0]
                layers[layer_name] = layer
                total_area_per_layer[layer_name] = 0  # Initialiser la superficie totale à 0


   



 

        # Sélectionner les entités intersectantes et calculer la superficie totale par couche
        for layer_name, layer in layers.items():
            intersected_area = 0
            intersecting_features = [feature for feature in layer.getFeatures() if feature.geometry().intersects(buffer)]
            for feature in intersecting_features:
                intersected_area += feature.geometry().intersection(buffer).area()
            total_area_per_layer[layer_name] = intersected_area




        # Créer le buffer
        #buffer = self.create_buffer(new_centroid, buffer_radius)
        # Sélectionner les entités intersectantes et calculer la superficie totale par couche





            # Récupérer les données pour l'export
            export_data = []
            total_buffer_area = buffer.area()

            for layer_name, layer in  layers.items():
                intersecting_features = [feature for feature in layer.getFeatures() if feature.geometry().intersects(buffer)]
                for feature in intersecting_features:
                    attributes = feature.attributes()[:5]
                    feature_area = feature.geometry().area()
                    percentage = (feature_area / total_buffer_area) * 100
                    attributes.append(percentage)
                    export_data.append(attributes)

      







        self.select_intersecting_features(buffer,couches)
        self.generate_tables(buffer, self.lineEdit_4.text())
        self.plot_statistics(total_area_per_layer, buffer.area(), len(export_data), self.check_project_viability( layers,total_buffer_area))
# Convertir le dictionnaire en une chaîne de caractères lisible
        results = self.check_project_viability( layers,total_buffer_area)
        results_str = "\n".join([f"{key}: {value}" for key, value in results.items()])

        # Afficher la chaîne de caractères dans un QLabel
        self.label_7.setText(results_str)

        
        # Générer le graphique Plotly à barres
        #analysis_plot = self.generate_analysis_plot(total_area_per_layer)

        # Visualiser le graphique Plotly
        #analysis_plot.show()











    def check_project_viability(self, intersecting_layers, buffer_area):
        results = {}

        # Vérifier l'intersection avec la couche de domaine forestier
        if "DOMAINE_FORESTIER" in intersecting_layers:
            results["Résultats pour la couche Domaine Forestier"] = "Intersection du buffer crée avec la couche de domaine forestier"
        else:
            results["Résultats pour la couche Domaine Forestier"] = "Pas d'intersection du buffer avec la couche de domaine forestier"
        # Vérifier l'intersection avec la couche de domaine privé
        if "DOMIANE_PRIVE_ETAT" in intersecting_layers:
            results["Résultats pour la couche Domaine Privé"] = "Intersection du buffer avec la couche de domaine privé"
        else:
            results["Résultats pour la couche Domaine Privé"] = "Pas d'intersection du buffer avec la couche de domaine privé"

        # Vérifier l'intersection avec la couche de dérogation (ne doit pas dépasser 5 entités)
        for layer_name in intersecting_layers:
            layer = QgsProject.instance().mapLayersByName(layer_name)[0] if QgsProject.instance().mapLayersByName(layer_name) else None
            if layer and layer.name() == "Derogation_central_13_avril":
                feature_count = layer.selectedFeatureCount()

                if feature_count > 5:
                    results["Résultats pour la couche Derogation"] = f"Intersection du buffer avec plus de 5 projets dérogé ({feature_count} entités intersectées)"
                else:
                    results["Résultats pour la couche Derogation"] = f"Intersection du buffer avec {feature_count} projets dérogé"
                break

        # Vérifier la surface du projet si un fichier GeoJSON est fourni
        if self.checkBox.isChecked():
            geojson_file = self.lineEdit.text()
            # Charger le GeoDataFrame à partir du fichier GeoJSON
            input_data = gpd.read_file(geojson_file)

            # Calculer la superficie du projet
            project_area = input_data.unary_union.area
            print(project_area)
            # Formater la superficie avec deux décimales et sans notation scientifique
            formatted_area = round(project_area, 2)
            print(formatted_area)

            # Vérifier si la surface dépasse 1 hectare (10 000 mètres carrés)
            if project_area < 10000:
                results["Surface Projet"] = f"La surface du projet est {project_area} m² donc la condition de la surface n'est pas vérifiée"
            else:
                results["Surface Projet"] = f"La surface du projet est {project_area} m² donc la condition de la surface est vérifiée"

        # Si aucune des conditions précédentes n'est vérifiée, le projet est considéré comme viable
        if not results:
            results["Décision :  "] = "Projet favorable il respecte tous les conditions"
        print(results)
        return results






































    def generate_tables(self, buffer, output_pdf):
        # Initialiser une liste pour stocker les DataFrames pandas
        dataframes = []
        intersecting_layers = {}
        couches = ["COLLECTIF", "DOMAINE_FORESTIER", "DOMAINE_COMMUNAL", "Derogation_central_13_avril", "DOMAINE_PUBLIC", "DOMIANE_PRIVE_ETAT"]

        elements = []



        # Sélectionner les entités intersectantes pour chaque couche
        for layer_name in couches:
            layer = QgsProject.instance().mapLayersByName(layer_name)
            if layer:
                layer = layer[0]
                intersecting_features = [feature for feature in layer.getFeatures() if feature.geometry().intersects(buffer)]
                if intersecting_features:  # Vérifier s'il y a des entités intersectantes
                    intersecting_layers[layer_name] = intersecting_features
     

        # Calculer la superficie totale du buffer
        total_buffer_area = buffer.area()

        # Créer le document PDF
        doc = SimpleDocTemplate(output_pdf, pagesize=A3)
  



                # Définir le style du titre
        title_style = ParagraphStyle(
            name='TitleStyle',
            fontName='Helvetica-Bold',
            fontSize=16,
            textColor=colors.HexColor("#C00000"),
            alignment=1,
            spaceAfter=12 , # Espacement après le titre
        )

        # Texte du titre
        title_text = "Rapport d'analyse spatiale"

        # Ajouter le titre au document
        title = Paragraph(title_text, title_style)

        elements.append(title)
            # Ajouter un espace après le titre
        elements.append(Spacer(1, 0.5 * inch))
   


        #self.generate_study_area_map()
        #image_file = self.save_map_as_image('study_area_map.html', 'C:/Users/btiss/Downloads/test_images/study_area_map.png')
        # Charger l'image
       # image = Image(image_file)

        # Ajouter le titre et l'image au PDF
       # doc.build([title, image])


        #self.generate_study_area_map(buffer)

        # Création d'un nouveau PDF
        #c = canvas.Canvas("output.pdf", pagesize=letter)



        #image_path = "C:/Users/btiss/Downloads/test_images/map_image.jpeg"
        #image = Image(image_path, width=400, height=400)
        #doc.build([image])
        elements.append(Spacer(2, 0.5 * inch))
        #elements.append(image)

        

        # Parcourir les couches intersectantes
        for layer_name, features in intersecting_layers.items():
            # Initialiser une liste pour stocker les données des entités intersectantes
            rows = []
            field_names=[]

            # Parcourir les entités intersectantes de la couche
            for feature in features:
                # Récupérer les attributs de la table attributaire
                attributes = feature.attributes()

                # Récupérer les noms des champs de la couche
                field_names = [field.name() for field in layer.fields()][:5]  # Récupère les noms des 5 premiers champs

                # Calculer la superficie de l'entité intersectante
                feature_area = feature.geometry().area()

                # Calculer le pourcentage de la surface totale du buffer
                percentage = round((feature_area / total_buffer_area) * 100, 3)
                surface=round(feature_area , 3)
                # Ajouter les données de l'entité intersectante à la liste des lignes
                row_data =attributes[:5] +[surface]+ [percentage]  # Utilisez seulement les 5 premiers attributs
                rows.append(row_data)

            # Créer un DataFrame pandas à partir des données
            columns = field_names + ["Surface (m²)"]+["Pourcentage"]
            df = pd.DataFrame(rows, columns=columns)

            # Ajouter le DataFrame à la liste
            dataframes.append(df)

            # Convertir le DataFrame en tableau reportlab
            data = [df.columns.tolist()] + df.values.tolist()


            # Créer un style de paragraphe personnalisé
            mon_style_paragraphe = ParagraphStyle(
                name='MonStyleParagraphe',  # Nom du style
                fontName='Helvetica-Bold',  # Nom de la police
                fontSize=12,  # Taille de la police
                textColor= colors.HexColor('#E97132'), 
                spaceAfter =12, 
            )

            # Utiliser le style de paragraphe personnalisé
            layer_text = f"Tableau pour la couche : {layer_name}"
            elements.append(Paragraph(layer_text, mon_style_paragraphe))
            elements.append(Spacer(1,1*inch))

      
            

            # Créer le tableau et appliquer un style
            table = Table(data)
            style = TableStyle([('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#4D93D9')),
                                ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor("#FFFFFF")),
                                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                                ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor("#F2F2F2")),
                                ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#4D93D9'))])
            table.setStyle(style)

            # Ajouter le tableau au document PDF
            elements.append(table)
            elements.append(Spacer(1,1*inch))


        imagechart_path = "C:/Users/btiss/Downloads/test_images/statistics_pie_chart.png"
        image1 = Image(imagechart_path, width=400, height=400)
        imagebar_path = "C:/Users/btiss/Downloads/test_images/statistics_bar_chart.png"
        image2 = Image(imagebar_path, width=400, height=400)
    

     



        elements.append(image1)
                   
 
        elements.append(Spacer(2, 0.5 * inch))
        elements.append(image2)
        
        # Ajouter tous les éléments au document PDF et finaliser le document
        doc.build(elements)

        return dataframes












    def convert_coordinates1(self, x, y):
        # Convertir les coordonnées de l'EPSG 26191 à lat/lon
        input_geometry = QgsGeometry.fromPointXY(QgsPointXY(x, y))
        crs_src = QgsCoordinateReferenceSystem(26191)
        crs_dest = QgsCoordinateReferenceSystem(4326)  # EPSG 4326 pour lat/lon
        transform_context = QgsProject.instance().transformContext()
        transformer = QgsCoordinateTransform(crs_src, crs_dest, transform_context)
        input_geometry.transform(transformer)
        lat, lon = input_geometry.asPoint().y(), input_geometry.asPoint().x()
        return lat, lon




    def save_map_as_image(self,html_file, output_image):
        # Configurer le navigateur headless
        options = webdriver.ChromeOptions()
        options.add_argument('--headless')
        options.add_argument('--disable-gpu')
        options.add_argument('--window-size=1200x800')

        # Créer une instance du navigateur
        driver = webdriver.Chrome(options=options)
        driver.get(f'file:///{os.path.abspath(html_file)}')

        # Sauvegarder la capture d'écran
        screenshot_path = 'C:/Users/btiss/Downloads/test_images/screenshot.png'
        driver.save_screenshot(screenshot_path)
        driver.quit()

        # Charger l'image avec PIL et la sauvegarder
        img = Image.open(screenshot_path)
        img.save(output_image)
        return output_image 





    def generate_study_area_map(self, buffer):
        if self.checkBox_2.isChecked():
            x = float(self.lineEdit_2.text())
            y = float(self.lineEdit_3.text())
            lat, lon = self.convert_coordinates1(x, y)
            print(f"Coordonnées converties: lat={lat}, lon={lon}")

            # Définir les limites de la carte (bounding box) pour le Maroc
            mapbox_center = {'lat': lat, 'lon': lon}
            mapbox_bounds = {
                'lat': {'min': 21.0, 'max': 36.0},
                'lon': {'min': -17.0, 'max': -1.0}
            }

            # Créer la carte avec Plotly
            fig = go.Figure(go.Scattermapbox(
                mode="markers",
                lon=[lon],
                lat=[lat],
                marker={'size': 10},
                name ="projet de dérogation"))






       
            fig.update_layout(
                mapbox={
                    'style': "open-street-map",
                    'center': mapbox_center,
                    'zoom': 7,
                    'bearing': 0,
                    'pitch': 0
                },
                margin={"r": 0, "t": 0, "l": 0, "b": 0}, width =500)

            # Exporter la carte au format image
            pio.write_image(fig, 'C:/Users/btiss/Downloads/test_images/map_image.jpeg')

        elif self.checkBox.isChecked():
            geojson_file = self.lineEdit.text()
            print(geojson_file)
            with open(geojson_file, 'r') as f:
                data = json.load(f)
                print(data)

            lats = []
            lons = []

            # Récupérer les coordonnées de toutes les géométries du GeoJSON
            for feature in data['features']:
                geometry = feature['geometry']
                if geometry['type'] == 'Polygon':
                    coordinates = geometry['coordinates'][0]
                    poly_lats, poly_lons = zip(*coordinates)
                    lats.extend(poly_lons)  # Inverser l'ordre pour les latitudes
                    lons.extend(poly_lats)  # Inverser l'ordre pour les longitudes


            # Affichez les coordonnées pour le débogage
            print(f"Coordonnées GeoJSON: lats={lats}, lons={lons}")

            # Définir les limites de la carte (bounding box) pour le Maroc
            mapbox_center = {'lat': sum(lats) / len(lats), 'lon': sum(lons) / len(lons)}
            mapbox_bounds = {
                'lat': {'min': 21.0, 'max': 36.0},
                'lon': {'min': -17.0, 'max': -1.0}
            }

            # Créer la carte avec Plotly
            fig = go.Figure(go.Scattermapbox(
                mode="markers+lines",
                lon=lons,
                lat=lats,
                marker={'size': 10}))
            if buffer:
                buffer_coords = []
                for part in buffer.asPolygon():
                    for point in part:
                        buffer_coords.append((point.x(), point.y()))
                buffer_lats, buffer_lons = zip(*buffer_coords)
                fig.add_trace(go.Scattermapbox(
                    mode="lines",
                    lon=buffer_lons,
                    lat=buffer_lats,
                    line={'width': 2, 'color': 'red'},
                    name="Buffer"))
                


            # Exporter la carte au format image
            pio.write_image(fig, 'C:/Users/btiss/Downloads/test_images/map_image.jpeg')

        else:
            print("Veuillez spécifier les coordonnées ou le fichier GeoJSON.")
            return





    def generate_pdf_with_tables(dataframes):
        # Créer un objet Story pour stocker les paragraphes et les tables
        story = []

        # Définir le style du paragraphe
        styles = getSampleStyleSheet()
        style = styles["Normal"]

        # Parcourir les DataFrames et générer une table et un paragraphe pour chaque DataFrame
        for df in dataframes:
            # Ajouter un paragraphe pour indiquer ce que représente la table
            paragraph_text = "Tableau représentant les entités intersectantes pour la couche {}".format(df.columns[1])
            story.append(Paragraph(paragraph_text, style))

            # Convertir le DataFrame en une liste de listes pour la création de la table
            data = [df.columns.tolist()] + df.values.tolist()

            # Créer la table
            table = Table(data)

            # Ajouter le style à la table
            table.setStyle(TableStyle([('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                                    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                                    ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                                    ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                                    ('GRID', (0, 0), (-1, -1), 1, colors.black)]))

            # Ajouter la table à l'objet Story
            story.append(table)

        # Créer un document PDF avec l'objet Story
        doc = SimpleDocTemplate("tables.pdf", pagesize=letter)
        doc.build(story)


    def generate_figure_with_tables(self, pie_chart_trace, table_traces):
        # Créer une figure Plotly avec une sous-figure de type 'pie'
        fig = sp.make_subplots(rows=2, cols=1, subplot_titles=("Pie Chart", "Tables"), specs=[[{"type": "pie"}], [{"type": "table"}]])

        # Ajouter le graphique circulaire à la figure
        fig.add_trace(pie_chart_trace, row=1, col=1)

        # Ajouter les tables à la figure
        for table_trace in table_traces:
            fig.add_trace(table_trace, row=2, col=1)

        # Mettre à jour les mises en page
        fig.update_layout(height=800, width=1000, title_text="Analysis Results")

        # Enregistrer la figure dans un fichier HTML
        fig.write_html("analysis_results.html")







    def generate_pie_chart(self, percentages):
        # Extraire les clés (noms de couche) et les valeurs (pourcentages) du dictionnaire
        layers = list(percentages.keys())
        values = list(percentages.values())

        # Créer une trace de graphique en forme de cercle (Pie chart)
        pie_trace = go.Pie(labels=layers, values=values, hole=0.4)

        return pie_trace















    def convert_coordinates(self, x, y, src_crs, dest_crs):
        # Créer un transformateur pour convertir les coordonnées
        transformer = Transformer.from_crs(src_crs, dest_crs)

        # Convertir les coordonnées
        new_x, new_y = transformer.transform(y, x)  # Notez que Transformer utilise l'ordre (lat, lon) -> (y, x)

        # Créer un nouvel objet Point avec les nouvelles coordonnées
        new_point = QgsPointXY(new_x, new_y)

        return new_point

    def create_buffer(self, input_geometry, radius):
        # Convertir l'objet QgsPointXY en un objet QgsPointXY
        point = QgsPointXY(input_geometry.x(), input_geometry.y())
        # Créer le buffer à partir du point avec un rayon donné
        buffer = QgsGeometry.fromPointXY(point).buffer(radius, 50)

        # Créer la couche de buffer et spécifier le CRS
        buffer_layer = QgsVectorLayer("Polygon?crs=EPSG:26191", "Buffer", "memory")
        buffer_layer_provider = buffer_layer.dataProvider()
        buffer_feature = QgsFeature()
        buffer_feature.setGeometry(buffer)
        buffer_layer_provider.addFeatures([buffer_feature])
        QgsProject.instance().addMapLayer(buffer_layer)
    # Zoomer sur le buffer
        self.zoom_to_buffer(buffer_layer)
        return buffer




    def zoom_to_buffer(self, buffer_layer):
        # Récupérer l'étendue du buffer
        extent = buffer_layer.extent()

        # Zoomer sur l'étendue du buffer
        iface.mapCanvas().setExtent(extent)
        iface.mapCanvas().refresh()










